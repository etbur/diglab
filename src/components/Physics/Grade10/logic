import React, { useState, useRef, useEffect } from 'react';
import './RealTimeSimulation.css';

const RealTimeSimulation = () => {
  // State for components, wires, and simulation
  const [components, setComponents] = useState([]);
  const [wires, setWires] = useState([]);
  const [selectedTool, setSelectedTool] = useState('select');
  const [simulationRunning, setSimulationRunning] = useState(false);
  const [selectedComponent, setSelectedComponent] = useState(null);
  const [nextId, setNextId] = useState(1);
  const [wireStart, setWireStart] = useState(null);
  const canvasRef = useRef(null);

  // Component definitions
  const componentTypes = [
    { type: 'AND', label: 'AND', inputs: 2, outputs: 1, width: 60, height: 40 },
    { type: 'OR', label: 'OR', inputs: 2, outputs: 1, width: 60, height: 40 },
    { type: 'NOT', label: 'NOT', inputs: 1, outputs: 1, width: 50, height: 40 },
    { type: 'XOR', label: 'XOR', inputs: 2, outputs: 1, width: 60, height: 40 },
    { type: 'NAND', label: 'NAND', inputs: 2, outputs: 1, width: 70, height: 40 },
    { type: 'NOR', label: 'NOR', inputs: 2, outputs: 1, width: 60, height: 40 },
    { type: 'INPUT', label: 'INPUT', inputs: 0, outputs: 1, width: 50, height: 30 },
    { type: 'OUTPUT', label: 'OUTPUT', inputs: 1, outputs: 0, width: 50, height: 30 },
    { type: 'CLOCK', label: 'CLOCK', inputs: 0, outputs: 1, width: 60, height: 40 },
  ];

  // Add a new component to the canvas
  const addComponent = (type, x, y) => {
    const compType = componentTypes.find(ct => ct.type === type);
    const newComponent = {
      id: nextId,
      type,
      x,
      y,
      width: compType.width,
      height: compType.height,
      inputs: Array(compType.inputs).fill(false),
      outputs: Array(compType.outputs).fill(false),
      label: compType.label,
    };
    setComponents([...components, newComponent]);
    setNextId(nextId + 1);
  };

  // Get connection points for a component
  const getConnectionPoints = (component) => {
    const inputs = [];
    const outputs = [];
    
    for (let i = 0; i < component.inputs.length; i++) {
      inputs.push({
        x: component.x,
        y: component.y + (component.height / (component.inputs.length + 1)) * (i + 1),
        index: i,
        type: 'input'
      });
    }
    
    for (let i = 0; i < component.outputs.length; i++) {
      outputs.push({
        x: component.x + component.width,
        y: component.y + (component.height / (component.outputs.length + 1)) * (i + 1),
        index: i,
        type: 'output'
      });
    }
    
    return { inputs, outputs };
  };

  // Find connection point at coordinates
  const findConnectionAt = (x, y) => {
    for (const comp of components) {
      const points = getConnectionPoints(comp);
      
      for (const point of [...points.inputs, ...points.outputs]) {
        const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
        if (distance < 10) {
          return { component: comp, point };
        }
      }
    }
    return null;
  };

  // Handle mouse events on canvas
  const handleCanvasClick = (e) => {
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (wireStart) {
      // We're in wire drawing mode, try to complete the wire
      const endConnection = findConnectionAt(x, y);
      if (endConnection && endConnection.point.type !== wireStart.point.type) {
        // Valid connection - create wire
        const newWire = {
          id: wires.length + 1,
          from: { compId: wireStart.component.id, point: wireStart.point },
          to: { compId: endConnection.component.id, point: endConnection.point }
        };
        setWires([...wires, newWire]);
        
        // Update component connections
        if (wireStart.point.type === 'output') {
          // Output to input connection
          setComponents(components.map(comp => {
            if (comp.id === endConnection.component.id) {
              const newInputs = [...comp.inputs];
              newInputs[endConnection.point.index] = true;
              return { ...comp, inputs: newInputs };
            }
            return comp;
          }));
        } else {
          // Input to output connection
          setComponents(components.map(comp => {
            if (comp.id === endConnection.component.id) {
              const newOutputs = [...comp.outputs];
              newOutputs[endConnection.point.index] = true;
              return { ...comp, outputs: newOutputs };
            }
            return comp;
          }));
        }
      }
      setWireStart(null);
      return;
    }

    if (selectedTool !== 'select') {
      addComponent(selectedTool, x, y);
      setSelectedTool('select');
    } else {
      // Check if a connection point was clicked
      const connection = findConnectionAt(x, y);
      if (connection) {
        setWireStart(connection);
        return;
      }
      
      // Check if a component was clicked
      const clickedComponent = components.find(comp => 
        x >= comp.x && x <= comp.x + comp.width &&
        y >= comp.y && y <= comp.y + comp.height
      );
      
      setSelectedComponent(clickedComponent || null);
    }
  };

  // Calculate output based on component type and inputs
  const calculateOutput = (component) => {
    switch (component.type) {
      case 'AND':
        return [component.inputs.every(i => i)];
      case 'OR':
        return [component.inputs.some(i => i)];
      case 'NOT':
        return [!component.inputs[0]];
      case 'XOR':
        return [component.inputs[0] !== component.inputs[1]];
      case 'NAND':
        return [!component.inputs.every(i => i)];
      case 'NOR':
        return [!component.inputs.some(i => i)];
      case 'INPUT':
        return [component.outputs[0]]; // Input components maintain their state
      case 'CLOCK':
        return [Math.floor(Date.now() / 500) % 2 === 0]; // Toggle every 500ms
      default:
        return [false];
    }
  };

  // Propagate signals through the circuit
  const propagateSignals = () => {
    // First update all component outputs based on their inputs
    let updatedComponents = components.map(comp => {
      if (comp.type === 'INPUT' || comp.type === 'OUTPUT') return comp;
      
      return {
        ...comp,
        outputs: calculateOutput(comp)
      };
    });

    // Then update inputs based on connected outputs
    for (const wire of wires) {
      const fromComp = updatedComponents.find(c => c.id === wire.from.compId);
      const toComp = updatedComponents.find(c => c.id === wire.to.compId);
      
      if (fromComp && toComp) {
        if (wire.from.point.type === 'output' && wire.to.point.type === 'input') {
          // Update the input of the destination component
          toComp.inputs[wire.to.point.index] = fromComp.outputs[wire.from.point.index];
        }
      }
    }

    setComponents(updatedComponents);
  };

  // Run simulation
  useEffect(() => {
    if (!simulationRunning) return;

    const simulate = () => {
      propagateSignals();
    };

    const interval = setInterval(simulate, 100);
    return () => clearInterval(interval);
  }, [simulationRunning, components, wires]);

  // Toggle input components
  const toggleInput = (id, outputIndex) => {
    setComponents(components.map(comp => {
      if (comp.id === id && comp.type === 'INPUT') {
        const newOutputs = [...comp.outputs];
        newOutputs[outputIndex] = !newOutputs[outputIndex];
        return { ...comp, outputs: newOutputs };
      }
      return comp;
    }));
  };

  // Render wires on canvas
  const renderWires = () => {
    return wires.map(wire => {
      const fromComp = components.find(c => c.id === wire.from.compId);
      const toComp = components.find(c => c.id === wire.to.compId);
      
      if (!fromComp || !toComp) return null;
      
      const fromPoint = getConnectionPoints(fromComp)[wire.from.point.type + 's'][wire.from.point.index];
      const toPoint = getConnectionPoints(toComp)[wire.to.point.type + 's'][wire.to.point.index];
      
      const isActive = wire.from.point.type === 'output' ? 
        fromComp.outputs[wire.from.point.index] : 
        toComp.inputs[wire.to.point.index];
      
      return (
        <line
          key={wire.id}
          x1={fromPoint.x}
          y1={fromPoint.y}
          x2={toPoint.x}
          y2={toPoint.y}
          stroke={isActive ? "#0f0" : "#f00"}
          strokeWidth="2"
        />
      );
    });
  };

  // Render components on canvas
  const renderComponents = () => {
    return components.map(comp => {
      const isSelected = selectedComponent && selectedComponent.id === comp.id;
      const connectionPoints = getConnectionPoints(comp);
      
      let fillColor = '#ddd';
      if (comp.type === 'INPUT') fillColor = comp.outputs[0] ? '#9f9' : '#f99';
      if (comp.type === 'OUTPUT') fillColor = comp.inputs[0] ? '#9f9' : '#f99';
      if (comp.type === 'CLOCK') fillColor = comp.outputs[0] ? '#9cf' : '#c9f';
      
      return (
        <g key={comp.id} onClick={() => setSelectedComponent(comp)}>
          <rect
            x={comp.x}
            y={comp.y}
            width={comp.width}
            height={comp.height}
            fill={fillColor}
            stroke={isSelected ? '#00f' : '#000'}
            strokeWidth={isSelected ? 2 : 1}
            rx={5}
          />
          <text
            x={comp.x + comp.width / 2}
            y={comp.y + comp.height / 2 + 5}
            textAnchor="middle"
            fontSize="14"
            fill="#000"
          >
            {comp.label}
          </text>
          
          {/* Input connectors */}
          {connectionPoints.inputs.map((point, i) => (
            <circle
              key={`in-${i}`}
              cx={point.x}
              cy={point.y}
              r={5}
              fill={comp.inputs[i] ? '#0f0' : '#f00'}
            />
          ))}
          
          {/* Output connectors */}
          {connectionPoints.outputs.map((point, i) => (
            <circle
              key={`out-${i}`}
              cx={point.x}
              cy={point.y}
              r={5}
              fill={comp.outputs[i] ? '#0f0' : '#f00'}
              onClick={(e) => {
                e.stopPropagation();
                if (comp.type === 'INPUT') toggleInput(comp.id, i);
              }}
              style={{ cursor: comp.type === 'INPUT' ? 'pointer' : 'default' }}
            />
          ))}
        </g>
      );
    });
  };

  // Draw temporary wire when connecting
  const renderTemporaryWire = () => {
    if (!wireStart) return null;
    
    return (
      <line
        x1={wireStart.point.x}
        y1={wireStart.point.y}
        x2={wireStart.point.x}
        y2={wireStart.point.y}
        stroke="#999"
        strokeWidth="2"
        strokeDasharray="5,5"
      />
    );
  };

  return (
    <div className="real-time-simulator">
      <h1>Real-Time Electronics Simulator</h1>
      
      <div className="simulator-container">
        <div className="toolbar">
          <h3>Components</h3>
          {componentTypes.map(comp => (
            <button
              key={comp.type}
              className={selectedTool === comp.type ? 'selected' : ''}
              onClick={() => setSelectedTool(comp.type)}
            >
              {comp.label}
            </button>
          ))}
          
          <button
            className={selectedTool === 'wire' ? 'selected' : ''}
            onClick={() => setSelectedTool('wire')}
          >
            Draw Wire
          </button>
          
          <div className="simulation-controls">
            <button 
              onClick={() => setSimulationRunning(!simulationRunning)}
              className={simulationRunning ? 'stop' : 'start'}
            >
              {simulationRunning ? 'Stop Simulation' : 'Start Simulation'}
            </button>
            <button onClick={() => {
              setComponents([]);
              setWires([]);
              setSelectedComponent(null);
              setWireStart(null);
            }}>
              Clear Canvas
            </button>
          </div>
        </div>
        
        <div className="canvas-container">
          <svg 
            ref={canvasRef}
            className="simulation-canvas"
            onClick={handleCanvasClick}
          >
            {renderWires()}
            {renderTemporaryWire()}
            {renderComponents()}
          </svg>
        </div>
        
        <div className="properties-panel">
          <h3>Properties</h3>
          {selectedComponent ? (
            <div>
              <p><strong>Type:</strong> {selectedComponent.type}</p>
              <p><strong>Inputs:</strong> {selectedComponent.inputs.map((inp, i) => 
                <span key={i} className={inp ? 'high' : 'low'}>{inp ? '1' : '0'}</span>
              )}</p>
              <p><strong>Outputs:</strong> {selectedComponent.outputs.map((out, i) => 
                <span key={i} className={out ? 'high' : 'low'}>{out ? '1' : '0'}</span>
              )}</p>
              
              {selectedComponent.type === 'INPUT' && (
                <button onClick={() => toggleInput(selectedComponent.id, 0)}>
                  Toggle State
                </button>
              )}
            </div>
          ) : wireStart ? (
            <p>Click on a connection point to complete the wire</p>
          ) : (
            <p>Select a component or draw a wire</p>
          )}
        </div>
      </div>
      
      <div className="instructions">
        <h3>How to Use the Simulator</h3>
        <ol>
          <li>Select a component from the toolbar</li>
          <li>Click on the canvas to place it</li>
          <li>Click on input components to toggle their state</li>
          <li>Select "Draw Wire" to connect components</li>
          <li>Start the simulation to see logic propagation</li>
        </ol>
      </div>
    </div>
  );
};

export default RealTimeSimulation;   


/* RealTimeSimulation.css */
.real-time-simulator {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  background: #f5f5f5;
  min-height: 100vh;
}

h1 {
  text-align: center;
  color: #2c3e50;
  margin-bottom: 20px;
  padding: 10px;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.simulator-container {
  display: flex;
  gap: 20px;
  margin-bottom: 30px;
}

.toolbar {
  width: 200px;
  background: #f5f5f5;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.toolbar h3 {
  margin-top: 0;
  color: #2c3e50;
  border-bottom: 1px solid #ddd;
  padding-bottom: 10px;
}

.toolbar button {
  display: block;
  width: 100%;
  padding: 10px;
  margin-bottom: 10px;
  background: #ecf0f1;
  border: 1px solid #bdc3c7;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
}

.toolbar button:hover {
  background: #d6dbdf;
}

.toolbar button.selected {
  background: #3498db;
  color: white;
  border-color: #2980b9;
}

.simulation-controls {
  margin-top: 20px;
  border-top: 1px solid #ddd;
  padding-top: 20px;
}

.simulation-controls button {
  background: #2ecc71;
  color: white;
  border: none;
}

.simulation-controls button.stop {
  background: #e74c3c;
}

.simulation-controls button:hover {
  opacity: 0.9;
}

.canvas-container {
  flex: 1;
  height: 600px;
  border: 1px solid #bdc3c7;
  border-radius: 8px;
  overflow: hidden;
  background: #fff;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.simulation-canvas {
  width: 100%;
  height: 100%;
  background: #f9f9f9;
  cursor: crosshair;
}

.properties-panel {
  width: 250px;
  background: #f5f5f5;
  padding: 15px;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.properties-panel h3 {
  margin-top: 0;
  color: #2c3e50;
  border-bottom: 1px solid #ddd;
  padding-bottom: 10px;
}

.high {
  color: #27ae60;
  font-weight: bold;
  margin: 0 3px;
}

.low {
  color: #c0392b;
  font-weight: bold;
  margin: 0 3px;
}

.instructions {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.instructions h3 {
  color: #2c3e50;
  margin-top: 0;
}

.instructions ol {
  padding-left: 20px;
}

.instructions li {
  margin-bottom: 10px;
}




